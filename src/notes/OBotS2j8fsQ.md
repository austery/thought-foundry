---
author: Unknown
date: '2025-10-30'
guest: ''
layout: post.njk
source: https://www.youtube.com/watch?v=OBotS2j8fsQ
speaker: Unknown
tags:
  - semantic-versioning
  - ai-model-versioning
  - developer-trust
  - software-ecosystem
  - marketing-strategy
title: 当版本号不再可信：AI时代软件迭代的信任危机
summary: 本文探讨了软件版本号在AI时代面临的信任危机。传统软件开发中，语义化版本号（Semantic Versioning）提供了清晰的迭代预期，但这一默契在大模型和某些封闭生态中被打破。文章分析了版本号混乱的原因，如AI黑箱特性、营销驱动以及开发者承诺的缺失，并指出这最终损害了用户和开发者的信任，导致生态系统健康受损。
insight: ''
draft: true
series: ''
category: technology
area: tech-insights
project:
  - ai-impact-analysis
  - systems-thinking
people:
  - Linus Torvalds
companies_orgs:
  - npm
  - Microsoft
  - 腾讯
products_models:
  - Python
  - Postgres
  - Linux kernel
  - GPT
  - Claude
  - Windows XP
  - Windows Vista
  - 微信小程序
media_books: []
status: evergreen
---
### AI时代版本号的困惑

在制作本期视频时，我想先通过**AI**（Artificial Intelligence: 人工智能）了解一下版本号的发展史。当我打开**Copilot**（GitHub Copilot: 一款由AI驱动的代码助手，此处泛指AI聊天助手）时，我看到了15个可供选择的**大模型**（Large Language Model: 拥有巨大参数量和数据训练的AI模型），但我不知道该选哪个，因为我已经搞不懂它们有什么区别了。有时候4的回答比4.1和5更详细，有时候3.7的答案会比3.5和4.5更精准。所以每次我都要挨个问一遍，再货比三家得出结论。我十分怀念那个什么软件都可以无脑使用最新版本的时代。约定俗成的版本命名规则在AI时代已经荡然无存。

### 传统软件版本号的默契与规范

在计算机行业，一直以来我们都有一个默契，用统一的表达方式来传达产品的迭代更新，这个表达方式就是版本号。**Semantic Versioning**（语义化版本控制: 一种软件版本号规范，通过主版本号、次版本号和修订号来传达更新的兼容性）就是一个很优秀的版本号格式。它由**major**（主版本号: 表示不兼容的API更改）、**minor**（次版本号: 表示向后兼容的功能性新增）和**patch**（修订号: 表示向后兼容的错误修复）三个数字组成。

当一个产品的新版本包含影响重大的更新时，major就会上升一个数。比如**Python**（Python: 一种广泛使用的编程语言）圈子花了12年才完成的2.7到3.0的交接，这是因为代码不兼容，需要集体大规模重构。如果这个更新只包含一些可有可无的小功能，就会在minor上加一。如果发布的是某个bug的修复补丁，顾名思义，patch就会加1。Semantic Versioning通过三个数字的组合浓缩了几乎所有产品迭代更新的情况，这也让它成为业内几乎默认的版本号格式。

### 版本号的灵活运用与预期管理

在这个基础上，不同产品也会根据自己的特殊情况进行调整。成熟的项目管理能让产品的发布周期稳定下来。比如10.0之后的世界上最好的数据库**Postgres**（PostgreSQL: 一种开源的关系型数据库管理系统）会集中在每年的9月到10月左右发布新版本。所以他们会使用相对简洁的major加上patch的双数字格式，每年9月份major加一，剩下的时间里不定时发布补丁。作为Postgres的使用者，或者基于Postgres进行二次开发的程序员，都能有明确的预期管理，让整个Postgres生态更加稳定健康。

又比如**Linux内核**（Linux Kernel: Linux操作系统的核心部分）也有固定的发布周期，但因为它的周期只有8个星期，所以major号膨胀得特别快。作为一个已经运作了30多年的项目，版本号码太大会很影响交流和传播。所以聪明的**Linus**（Linus Torvalds: Linux内核的创始人）决定把三数字格式当双数字格式用。2011年开始，每过大约20个周期，Linus就会让minor数归零，major数加一，就像加法那样进位。所以那些不太熟悉Linux生态的人，可能会误以为4.20到5.0或者5.19到6.0都是什么重大的系统更新，其实并不是，只是Linux刚好那天起床气比较重，决定cosplay一下归零者。

有用短号的，自然也有用长号的。尤其是在**CI/CD**（Continuous Integration/Continuous Delivery: 持续集成/持续交付，一种软件开发实践）成熟的团队，一天发布10次也不为过，版本号自然复杂一些。但不管这些数字多长，有一点是不变的：开发者承诺了某种迭代更新的规律，用户由此可以更放心地按需升级。

### 依赖管理中的信任与漏洞

这种默契可以驱动非常大型的技术生态，比如大多数编程语言都有的**package/dependency机制**（包/依赖机制: 软件项目中管理外部库和模块的系统）。在一个项目里引用成百上千个依赖，每个依赖都有自己的依赖，无穷无尽。如果要程序员自己去逐一管理、逐一检查每个依赖的更新，再去决定要不要升级依赖，那将会是不可能完成的任务。这个机制能存活下来，正是因为大家对于Semantic Versioning版本号的默契。作为依赖的使用者，我们能大胆地接受所有依赖的所有patch版本更新，因为大大小小的新功能我们可能用不上，但现有功能的补丁修复总是需要的。

当然，这种默契也会被不怀好意的人所利用。比如每隔半年左右，**Node.js**（Node.js: 一个基于Chrome V8 JavaScript引擎的JavaScript运行时环境）生态里就会出现被**黑客**（Hacker: 利用计算机技能进行非法入侵或破坏的人）攻陷的工具库，种下**木马**（Trojan Horse: 一种恶意软件，伪装成合法程序以欺骗用户安装）后以patch的形式发布。然后全世界千千万万的软件在第二天上班时自动更新依赖，集体中招。但我认为，这更多的是**npm**（Node Package Manager: Node.js的包管理器）这些包管理框架的安全机制上的缺陷，版本号只是一个导火索。默契真正脆弱的地方，其实来自于开发者的承诺。

### 承诺缺失：微信生态的反面教材

版本号这个东西，说白了就是一串数字。它没有任何国际标准，也没有任何法律约束力。它不像**license**（许可协议: 规定软件使用、分发和修改权利的法律文件）那样，什么可以做，什么必须做，什么不可以做，做了之后有什么法律后果，都有非常明确的定义。版本号的定义遵循与否，只在开发者的一念之间。

**微信生态圈**（WeChat Ecosystem: 围绕腾讯微信平台构建的各种服务和应用体系）就是一个教科书式的反面案例。就拿**小程序**（WeChat Mini Program: 微信平台内无需下载即可使用的轻量级应用）的基础库来说，虽然它的版本命名表面上遵循了Semantic Versioning，但是版本号和变更的关系、变更的内容范围，都和Semantic Versioning的定义没有一毛钱关系。在它的patch版本更新中，你可能会看到全新**渲染引擎**（Rendering Engine: 负责解析和显示网页或应用内容的软件组件）的发布，或者让基础组件的行为完全改变的功能改动，让人防不胜防。所以基础库每次发布更新公告，我们都得认真阅读、逐一核实，再决定要不要升级。

但就算这样，你还是会被打个措手不及。因为小程序的运行底层实际上是一个**黑箱**（Black Box: 指其内部工作原理不透明、无法直接观察的系统或过程），公开发布版本信息的基础库只是其中的一小部分，还有不少更新是不公开、不定时、不提醒的。而且这些更新会被直接推送到用户的微信上。这也意味着，哪天醒来，你随时可能收到用户愤怒的反馈，说你的小程序出故障了，不能用了。你**debug**（Debug: 调试，指发现并修复软件错误的过程）半天无果，到微信开发者社区发帖询问，半天后才会有官方工作人员在评论区留下一句：“这个功能昨天改了/删掉了/不兼容了。”这也是为什么到了今天，即使已经成为（中国）国内C端软件的半壁江山，小程序的技术生态还是那么差。因为没有几个人想为这种丝毫不尊重开发者的平台做工具。

### 大模型版本号的混乱与“黑箱”困境

而视频开头提到的大模型也走到了这个阶段。当纯粹的堆叠数据不再带来可观的性能跃升，大模型的版本号也开始变得混乱。**GPT**（Generative Pre-trained Transformer: 一系列由OpenAI开发的大型语言模型）的4.1不一定比4好，5.0不一定比4.1好。**Claude**（Claude: 一系列由Anthropic开发的大型语言模型）同时存在的3.5、3.7、4.0和4.5，并不是同一个模型的四次跃升，更像是四个完全不同的模型。AI公司彻底推翻了软件行业多年建立的认知体系——“新版是旧版的上位替代品”这个概念不再成立。而且所有版本的模型同时存在，同时提供服务，也让用户患上了选择困难症。

其实这也不能完全怪罪开发者，因为大模型本质上就是一个千亿维度的黑箱。谁也说不准那些权重数字改动之后，到底影响了哪些地方。没有人能写出一个准确的大模型“更新日志”。开发者能做的，只有围绕几个**Benchmark**（基准测试: 用于评估系统或组件性能、质量的标准测试）做测试，然后以他们的结果作为迭代的成果。这也是为什么有些人抱怨新模型更差了，有些人觉得新模型更好了，因为这完全取决于你的使用场景是不是和AI公司优化的那个部分刚好在同一个**local minima**（局部最小值: 在优化算法中，指函数在某个区域内的最低点，不一定是全局最低点）的坑里。而随着大模型的竞争开始进入下半场，各大公司疯狂发布新版本的模型，又几乎不下架那些旧版本，只会让更多的人不知所措。

### 营销驱动下的版本号滥用

既然这么误导人，为什么还是硬着头皮用数字版本来命名呢？无非就是因为普通消费者看不懂那些技术名词，那些专业的更新公告，但大家都能看懂数字。对于任何软件和硬件的消费，“买新不买旧”一直以来都被奉为真理。怎么判断什么是新的呢？数字越大，它就越新呗。这也是为什么**微软**（Microsoft: 一家全球知名的软件和硬件公司）折腾了**Windows XP**（Windows XP: 微软在2001年发布的操作系统）和**Windows Vista**（Windows Vista: 微软在2007年发布的操作系统）之后，还是乖乖地回归了数字版本号。

数字的信息密度和传播能力大于一切文字。在**宣发**（宣传与发行: 产品的推广和发布活动）和研发一样重要的大众行业，这就是最锋利的武器。只不过这个武器已然成为被滥用的工具。不讲武德的商家纯粹为了新闻效果，让宣发凌驾于研发之上，故意混淆版本的命名。某种程度上来说，这是一种“**狼来了**”（狼来了: 源自寓言故事，比喻多次撒谎后失去他人信任的行为）的行为。每次发生，用户的信任都会被削掉一点。

### 信任的消逝与生态的未来

因为对于任何软件或硬件产品，用户永远都处于弱势地位。受到知识门槛、商业机密、时间成本等因素的影响，用户永远没有办法了解产品的全貌。我们只能选择相信，相信商家会自觉遵守那些约定俗成的规律，相信他们在一步一个脚印地优化自己的产品，相信接下来这个版本是值得掏钱的大更新。那么当信任被榨干之后，还能剩下什么呢？