---
title: AI智能体“Vibe Coding”：代码质量如何？Claude、Google、OpenAI谁更胜一筹？
summary: 视频深入探讨了使用AI智能体进行“Vibe Coding”的实际效果，对比了Claude Code、Gemini CLI和OpenAI Codex，揭示了它们的优缺点、局限性，并对AI代码生成能力及其对未来AI发展的影响进行了分析。
area: tech-insights
category: technology
project:
- ai-impact-analysis
- vibe-coding
tags:
- ai-agent
- ai-limitations
- code-generation
- software-development
- vibe-coding
people: []
companies_orgs: []
products_models: []
media_books:
- internet-of-bugs
date: '2025-07-11'
author: Internet of Bugs
speaker: Internet of Bugs
draft: true
guest: ''
insight: ''
layout: post.njk
series: ''
source: https://www.youtube.com/watch?v=SwviApWpOT4
status: evergreen
---
### 智能体“Vibe Coding”的介绍与目的

So today, I'm going to talk about using agents for "Vibe Coding", or at least as close to "Vibe Coding" as I'm going to get.
今天，我将讨论如何使用**智能体**（Agents: 能够自主执行任务的AI系统）进行“**Vibe Coding**”（Vibe Coding: 一种轻松、不干预的AI辅助编程方式，通常涉及最少的人工监督），或者至少是尽可能接近这种方式。

This is not a coding video, and you shouldn't need to know how to code in order to follow it.
这不是一个编程视频，你不需要懂编程也能看懂。

In fact, I hope this video makes it to folks who are interested in "Vibe Coding", but aren't experienced coders.
事实上，我希望这个视频能触达那些对“Vibe Coding”感兴趣但并非经验丰富的程序员。

Because while I think it's great that people who don't code are interested in using these tools, I think they should go into it with their eyes open about what you're getting.
因为虽然我认为非程序员对使用这些工具感兴趣是件好事，但我认为他们应该带着清醒的认识去了解自己能得到什么。

So for those of you that are interested in coding details, I have a companion video on my other channel with plenty of details.
所以，对于那些对编程细节感兴趣的人，我在我的另一个频道上有一个配套视频，里面有大量的细节。

Links below and at the end of the video.
链接在下方和视频结尾。

So I'm going to compare three agentic tools, Claude Code, Gemini CLI, and OpenAI Codex.
我将比较三种**智能体工具**（Agentic Tools: 能够自主执行复杂任务的AI工具），分别是Claude Code、Gemini **CLI**（Command Line Interface: 命令行界面，一种通过文本命令与计算机交互的方式）和**OpenAI Codex**（OpenAI Codex: OpenAI开发的一种AI模型，能将自然语言翻译成代码）。

I'm going to tell you roughly how I've configured them and use them safely, how I evaluate them, and why I chose that method.
我将大致介绍我是如何配置它们并安全使用它们的，我是如何评估它们的，以及我为什么选择这种方法。

I'm going to tell you which of those three tools is absolutely not worth your time and why, and what the trade-offs are between the two decent ones, so you know which of them would be better fit for what you're trying to do.
我将告诉你这三种工具中哪一个完全不值得你投入时间，以及原因；还会说明另外两个不错的工具之间的权衡，这样你就能知道哪一个更适合你的需求。

And then I'm going to talk to you about their limitations, and boy, do they have some serious limitations.
然后我将和你们谈谈它们的局限性，天哪，它们确实有一些严重的局限性。

And a lot of people who are so excited about "Vibe Coding" aren't talking about these limitations.
许多对“Vibe Coding”如此兴奋的人并没有谈论这些局限性。

And let me make a quick pitch here for why this matters.
让我在这里快速说明一下为什么这很重要。

The prevailing wisdom in that "we're going to have human-level intelligent AI very soon now" camp, rests on the assumption that "very soon now," the AIs are going to get good enough that the AIs will start improving their own code faster than a human can.
在“我们很快就会拥有人类水平的智能AI”这种普遍观点中，其基础假设是“很快”，AI将变得足够好，能够比人类更快地改进自己的代码。

And that's what's supposed to lead to crazy increases in its intelligence.
而这正是导致其智能疯狂增长的原因。

I've linked a video called "What If AI Keeps Getting Smarter" Below? If you want more info on that.
我在下方链接了一个名为《如果AI持续变得更聪明会怎样》的视频，如果你想了解更多信息。

However, in order for AIs to rewrite their own code faster than we can, the AIs have to get better at writing code than humans are.
然而，为了让AI能够比我们更快地重写自己的代码，AI必须在编写代码方面比人类更出色。

And that's why I think this kind of "how well do AIs write code compared to professional software engineers" experimentation videos are so important.
这就是为什么我认为这种“AI编写代码与专业软件工程师相比表现如何”的实验视频如此重要。

I think of it kind of like an early warning system because as long as the AIs aren't as good as humans at writing software, then they're not likely to be able to improve their own code.
我把它看作是一种早期预警系统，因为只要AI在编写软件方面不如人类，它们就不太可能改进自己的代码。

And if they do start getting good enough to start potentially improving their own code, then I expect this kind of experimentation is where we'll get the first indications of that.
如果它们真的变得足够好，开始有可能改进自己的代码，那么我预计这种实验将是我们将获得最初迹象的地方。

So watch this space, because the closer they get to writing better code than humans, the closer us humans get to being FF-----.
所以请关注这个领域，因为它们越接近编写出比人类更好的代码，我们人类就越接近……

### 频道与主持人介绍

[computer startup music]
[电脑启动音乐]

This is "The Internet of Bugs."
这里是“Bug的互联网”。

My name is Carl.
我叫卡尔。

I've been a software professional for 35 plus years now.
我从事软件专业工作已经超过35年了。

And I'm trying to do my part to cut down the number of bugs out on the internet.
我正努力尽自己的一份力，减少互联网上的bug数量。

Toward that end, I want to talk about bugs generated by ""Vibe Coding"" so you can hopefully see past the hype and know what it can be used for and what it's not yet stable enough to accomplish.
为此，我想谈谈“Vibe Coding”产生的bug，这样你就能有望看清炒作的背后，了解它能用于什么，以及它尚未稳定到可以完成什么。

### “Vibe Coding”的定义

So "Vibe Coding" is starting to take on a bunch of different meanings to different people.
所以“Vibe Coding”开始对不同的人有了不同的含义。

But here's an excerpt from the original tweet that named it that explains how I'm gonna be using the term at least for today.
但这里有一段来自最初命名它的推文的摘录，它解释了至少在今天我将如何使用这个术语。

Quote, "There's a new kind of coding I call vibe coding where you fully get into the vibes.
引文：“有一种新的编程方式我称之为‘Vibe Coding’，你完全沉浸在氛围中。

I barely even touch the keyboard.
我几乎不碰键盘。

I "accept all" always.
我总是‘接受所有’。

I don't read the diffs anymore.
我不再阅读差异。

When I get error messages, I just copy paste them with no comment, usually that fixes it.
当我收到错误信息时，我只是复制粘贴，不加任何评论，通常这样就能解决问题。

It's not too bad for throwaway weekend projects, but it's not really coding.
对于一次性的周末项目来说还不错，但这并不是真正的编程。

I just see stuff, say stuff, run stuff and copy and paste stuff.
我只是看东西，说东西，运行东西，然后复制粘贴东西。

It mostly works."
它大部分时候都有效。”

### 评估方法与工具

So I did an evaluation project using these rules to start with anyway, with three different command line based agent coding tools.
所以，我一开始就使用这些规则进行了一个评估项目，使用了三种不同的基于命令行的智能体编程工具。

**Claude Code**, Gemini CLI and OpenAI Codex.
**Claude Code**（Claude Code: Anthropic公司的一款AI编程智能体工具），Gemini CLI和OpenAI Codex。

Then once I got to the end of the project, I opened up the code to compare the different tools and to see how they would measure up what's expected of professional programmers in the real world.
项目结束后，我打开代码，比较了不同的工具，看看它们如何达到现实世界中对专业程序员的期望。

Now, I don't like testing AI code generators or actual people.
现在，我不喜欢测试AI代码生成器或真人。

With coding riddles, I think it's dumb, no matter what the prevailing wisdom appears to be in the hiring process at most companies.
用编程谜题来测试，我认为这很愚蠢，无论大多数公司在招聘过程中普遍的看法是什么。

Because one, coding riddles are not a thing that comes up when you're really trying to get work done.
因为第一，当你真正想完成工作时，编程谜题根本不会出现。

And two, I found that many people who have memorized a bunch of coding riddles have a very over-inflated sense of how smart they think they are and often they get themselves into a hole that their team has to waste time digging them out of, often while they're kicking and screaming and pounding that they didn't get their way.
第二，我发现许多背诵了一堆编程谜题的人，对自己有多聪明有着过高的自我评价，他们常常把自己陷入困境，让团队不得不浪费时间把他们挖出来，而且他们通常还会又踢又叫，抱怨自己没有得逞。

I found a convenient site last year to use to evaluate coding AIs.
去年我找到一个方便的网站来评估编程AI。

If you've seen one of my previous AI coding comparison videos, you've heard about it before.
如果你看过我之前的AI编程比较视频，你以前就听说过它。

It's called code crafters and then make step-by-step coding challenges for programmers that are not only challenging, but that teach you how the internet really works by having you build simple versions of core internet technologies.
它叫做Code Crafters，它为程序员提供循序渐进的编程挑战，这些挑战不仅具有挑战性，而且通过让你构建核心互联网技术的简单版本来教你互联网的真实运作方式。

They are not sponsoring this video, but I do have an affiliate link below that you can use if you wanna check them out.
他们没有赞助这个视频，但我下方有一个联盟链接，如果你想查看它们可以使用。

And if you do, it might help me keep making more videos like this.
如果你这样做，它可能会帮助我继续制作更多这样的视频。

The challenge I'm using today is one I've used before.
我今天使用的挑战是我以前用过的。

It's the one I found that the **LLMs** (Large Language Models: 经过大量文本数据训练的AI模型，能够理解和生成类似人类的文本) have the easiest time with and that's building a simple web server using the Python programming language.
我发现这是大型语言模型最容易完成的挑战，那就是使用Python编程语言构建一个简单的网络服务器。

Python is one of, if not the most, common language in the dataset these models are trained on and unsurprisingly, there are a ton of examples about how to build a web server on the web that the AI companies find when they scrape it.
Python是这些模型训练数据集中最常见的语言之一，甚至可能是最常见的语言，毫不奇怪，网上有大量关于如何构建网络服务器的例子，AI公司在抓取数据时会找到这些例子。

So this should be pretty much as good as the AI's concurrently get on problems that aren't just coding riddles they've memorized.
因此，这应该与AI在处理非记忆性编程谜题时所能达到的最佳水平相当。

So let's see how good they actually do.
那么，让我们看看它们实际表现如何。

I was pretty hands off on this whole thing.
我在这整个过程中都相当放手。

I gave each tool a link to the webpage for its copy of the challenge and a browser connection that was all set up for it to use.
我给每个工具提供了一个指向其挑战副本网页的链接，以及一个已设置好供其使用的浏览器连接。

I told it to go to the page, read the directions and follow them.
我告诉它去那个页面，阅读说明并遵循它们。

Occasionally one would ask permission to do something.
偶尔会有工具请求执行某项操作的权限。

I pretty much always said yes, as long as it didn't involve something pointless like installing a new copy of a piece of software I already knew was installed.
我几乎总是同意，只要它不涉及一些毫无意义的事情，比如安装一个我已经知道已经安装的软件的新副本。

So to cut to the chase, two of the three, Gemini CLI from Google and Claude Code from Anthropic completed the challenge at basically at the exact same time.
所以，长话短说，三个工具中的两个，Google的Gemini CLI和Anthropic的Claude Code，基本上同时完成了挑战。

Wow, right at the same time.
哇，就在同一时间。

They each had different strengths and they both left things to be desired but they each got the job done.
它们各有不同的优点，也都有不足之处，但它们都完成了任务。

OpenAI's tool though failed pretty spectacularly on a couple of different fronts.
然而，OpenAI的工具在几个不同方面都相当惨烈地失败了。

### 视频内容概览与实验设置

Okay, so let me tell you about what's going on in the rest of this video.
好的，让我来告诉你本视频接下来的内容。

Next up I'm gonna be talking about how I set up the agents and how I ran them.
接下来我将谈谈我是如何设置智能体以及如何运行它们的。

Again, I'm not gonna go into a ton of detail because I have a longer video on my second channel where you can watch the whole thing play out in real time if you want.
再次强调，我不会深入太多细节，因为我在我的第二个频道上有一个更长的视频，如果你愿意，可以在那里实时观看整个过程。

But I'm gonna explain the basics here.
但我会在这里解释基本原理。

Then after I explain the setup, I'm gonna talk about OpenAI Codex failing miserably.
然后在我解释完设置之后，我将谈谈OpenAI Codex的惨败。

Then I'm gonna compare and contrast the two that did finish and talk about what each was better at than the other.
然后我将比较和对比那两个完成任务的工具，并讨论它们各自的优势。

And then I'm gonna talk about what's still missing, what risks people run by using "Vibe Coding" for production software, where things might be going from here.
然后我将谈谈仍然缺少什么，人们将“Vibe Coding”用于生产软件会面临哪些风险，以及未来可能的发展方向。

And then lastly, I'm gonna be talking about next steps for this channel.
最后，我将谈谈这个频道的下一步计划。

Like I said, this was the easiest challenge I can think to give them, and I'm not gonna stop there.
就像我说的，这是我能想到的最简单的挑战，我不会就此止步。

So there will be harder challenges and other variations coming up that you can subscribe if you want to see.
所以接下来会有更难的挑战和其他变体，如果你想看可以订阅。

I've got chapter markers for all these things, so feel free to jump around or skip the parts that aren't relevant to you.
我为所有这些内容都设置了章节标记，所以你可以随意跳转或跳过与你无关的部分。

Okay, onto the setup.
好的，进入设置部分。

I can't walk you through all the different things I tried to get all of this working and all the things I learned not to do along the way, but trust me, this was a culmination of months of on-and-off experimenting.
我无法向你详细介绍我为了让这一切正常运行所尝试的所有不同方法，以及我在此过程中学到的所有不该做的事情，但请相信我，这是我断断续续几个月实验的成果。

I'm just gonna give you what I finally got working.
我只告诉你我最终成功运行的方案。

So I'm using two physical machines here.
我在这里使用了两台物理机器。

I have a primary machine.
我有一台主机器。

It's a Mac studio that I use for my YouTube recording, editing, Final Cut Pro, that kind of stuff.
它是一台Mac Studio，我用它进行YouTube录制、编辑、Final Cut Pro等工作。

And then I have a second machine that runs Linux.
然后我还有一台运行Linux的辅助机器。

On that Linux machine, I have three virtual machines that all each also run Linux.
在那台Linux机器上，我有三台虚拟机，每台也运行Linux。

Each one of those virtual machines is dedicated to one of the coding agents.
这些虚拟机中的每一台都专门用于一个编程智能体。

They all mount a file system from the underlying host that they write their files to.
它们都挂载了底层主机的**文件系统**（File System: 操作系统用来管理和组织存储设备上文件的方法），并将文件写入其中。

That way I keep copies of what each agent is doing.
这样我就可以保留每个智能体操作的副本。

They can't hurt each other aside from starving each other of resources.
除了相互争夺资源外，它们不会相互影响。

And if one of the agents goes nuts, I can just kill it and roll the disk of that virtual machine back to a known good state.
如果其中一个智能体失控，我可以直接终止它，并将该虚拟机的磁盘回滚到已知良好状态。

The reason I'm going to all that trouble is because I'm running all of these agents in the most permissive or dangerous mode.
我之所以费这么大劲，是因为我以最宽松或最危险的模式运行所有这些智能体。

They don't ask for permissions before they do whatever they think they want to do.
它们在执行自认为想做的任何事情之前，都不会请求权限。

If they screw up, they could wipe out the files on the machine and make it unbootable.
如果它们搞砸了，可能会擦除机器上的文件，导致机器无法启动。

I tell you that to warn you that if you don't want to go to this much trouble, you should run your agents in a mode where they have to ask you for permission before they do things.
我告诉你这些是为了警告你，如果你不想这么麻烦，你应该以一种模式运行你的智能体，即它们在执行操作之前必须征求你的许可。

If you run agents in a permissive mode on a machine that you care about and they delete all your files, crash your machine and you can't get into it anymore, don't say I didn't warn you and don't come crying to me.
如果你在你的重要机器上以宽松模式运行智能体，而它们删除了你所有的文件，导致你的机器崩溃，你再也无法进入，不要说我没有警告过你，也不要来找我哭诉。

And yes, I've had something like that happen.
是的，我确实遇到过类似的事情。

In an earlier version of this experiment, I had all three agents running on the same time on one much larger virtual machine and one of the agents or some combination of them ran it completely out of swap space, crashed it and corrupted part of the file system.
在这个实验的早期版本中，我曾让所有三个智能体同时运行在一个更大的虚拟机上，其中一个智能体或它们的某种组合耗尽了所有的**交换空间**（Swap Space: 硬盘或固态硬盘上用于虚拟内存的部分），导致虚拟机崩溃并损坏了部分文件系统。

Not sure exactly what happened or what or which one was at fault, but it hasn't happened since I separated them, but that doesn't mean it couldn't happen again.
不确定具体发生了什么，或者哪个是罪魁祸首，但自从我将它们分开后就再也没有发生过，但这并不意味着它不会再次发生。

So the other piece of the experiment is the web browser.
所以实验的另一个部分是网络浏览器。

I'm running three instances of Chrome on the main Mac, each one with a different profile directory and using a different **web socket debugging port** (Web Socket Debugging Port: 用于通过WebSocket连接调试Web应用程序的端口)。
我在主Mac上运行了三个Chrome实例，每个实例都有不同的配置文件目录，并使用不同的WebSocket调试端口。

Then I forced the agents to use the browser assigned to them to talk to the web via a library like **PlayRite** (Playwright: 一个用于自动化Web浏览器的库) or browser use.
然后我强制智能体使用分配给它们的浏览器，通过像Playwright或Browser Use这样的库与网络通信。

This is for two reasons.
这有两个原因。

One, so I can set up all the **authentication** (Authentication: 验证用户或系统身份的过程) for them talking to the internet, which is a lot easier than trying to teach them to understand **two factor authentication** (Two-factor Authentication (2FA): 一种安全方法，需要两种不同的因素来验证用户身份) and all that stuff.
第一，这样我就可以为它们与互联网通信设置所有认证，这比试图教它们理解双因素认证等所有东西要容易得多。

And second, so I can watch what they're doing and kill the browser process if it starts to try to do something stupid.
第二，这样我就可以观察它们在做什么，如果它开始尝试做一些愚蠢的事情，我可以终止浏览器进程。

So for the record, my end goal here is to be able to use these agents to write code that can automate some of the tedious tasks that I have to do on YouTube's site as a YouTube creator.
所以，记录一下，我在这里的最终目标是能够使用这些智能体编写代码，以自动化我作为YouTube创作者在YouTube网站上必须做的一些繁琐任务。

So in this evaluation, I'm using and testing an authentication mechanism that's similar to the two factor authentication that Google uses for YouTube.
因此，在此次评估中，我正在使用和测试一种类似于Google用于YouTube的双因素认证机制。

You might be able to use a simpler browser setup for your own problems depending on what you're trying to do.
根据你想要做什么，你可能可以使用更简单的浏览器设置来解决你自己的问题。

Now there's a thing you might have heard of that I'm not using called **MCP** (Model Context Protocol: 一种允许AI智能体与各种工具交互的协议) or Model Context Protocol.
现在，你可能听说过一个我没有使用的东西，叫做MCP，即模型上下文协议。

That lets these agents talk to various tools.
它让这些智能体能够与各种工具对话。

And I know there are people out there that use Microsoft's Playwright MCP or some equivalent to enable the agents to talk to a browser.
我知道有些人使用微软的Playwright MCP或类似的工具来让智能体与浏览器对话。

Personally, I haven't had good luck with that.
就我个人而言，我在这方面运气不佳。

I tell the agents to write their own code using the Playwright library instead.
我反而让智能体自己编写使用Playwright库的代码。

And I run that instead of using the MCP.
我运行那个，而不是使用MCP。

This is because when there is an error, I can look at the code they wrote and figure out what's going on.
这是因为当出现错误时，我可以查看它们编写的代码，找出问题所在。

When they try to use the MCP and something goes wrong, I have a lot less visibility into what they were trying to do, so it's a lot harder for me to troubleshoot.
当它们尝试使用MCP并且出现问题时，我对其尝试做什么的可见性大大降低，因此我很难进行故障排除。

You might be able to get away with using it.
你可能可以尝试使用它。

I know some people that are having good luck with it, and if it works for you, it might be easier for you.
我知道有些人用它很顺利，如果它对你有效，那对你来说可能会更容易。

But with my setup, it's been less than helpful.
但根据我的设置，它并没有多大帮助。

### OpenAI Codex的惨败

Okay, so let's talk about OpenAI's Codex project.
好的，现在我们来谈谈OpenAI的Codex项目。

So first off, Codex refused to work for me at all out of the box.
首先，Codex开箱即用对我来说根本无法工作。

I got this error about my organization being unverified.
我收到了一个关于我的组织未经验证的错误。

And then when I went to that link, then it sent me to this creepy other site where it wanted me to sign away my biometric information.
然后当我点击那个链接时，它把我带到了另一个令人毛骨悚然的网站，在那里它要求我签署放弃我的生物识别信息。

I'm not doing that, and I recommend you don't either, especially not for the tool that turned out to be the weakest of the three by far.
我不会那样做，我也不建议你这样做，尤其不是为了这个结果证明是三者中最弱的工具。

The other problem with OpenAI's tool is, at least for me, it doesn't have a working permissive mode.
OpenAI工具的另一个问题是，至少对我而言，它没有一个可用的宽松模式。

The way it does **sandboxing** (Sandboxing: 一种安全机制，用于在隔离环境中运行程序) is useless for my purposes.
它进行沙盒处理的方式对我的目的来说毫无用处。

It might be safer for someone who doesn't know what they're doing, but I think the other tools are pretty clear about what's going on, so I just don't think it's necessary to do the extra steps that OpenAI is doing.
对于不了解情况的人来说，它可能更安全，但我认为其他工具对正在发生的事情都非常清楚，所以我认为OpenAI所做的额外步骤没有必要。

And it made it impossible for me to make an apples-to-apples apples-to-apples comparison to the other tools.
这使得我无法与其他工具进行真正的“苹果对苹果”的比较。

So for this test, I was using a modified version of OpenAI's tool.
所以为了这次测试，我使用了OpenAI工具的一个修改版本。

I went through the changes that I made in the video on my other channel, but they were basically ripping out all the code related to projects, organizations, access token claims, and sandboxing.
我在我的另一个频道的视频中详细介绍了所做的更改，但它们基本上是删除了所有与项目、组织、访问令牌声明和沙盒相关的代码。

I don't have any reason to believe that these changes should have affected the results I got.
我没有理由相信这些更改会影响我得到的结果。

If on the other hand, it turns out that despite appearances, you can only get halfway decent results from OpenAI by giving away your biometric information, then you can make that decision for yourself, but I'm not doing that.
另一方面，如果事实证明，尽管表面上看起来，你只有通过放弃生物识别信息才能从OpenAI获得差强人意的结果，那么你可以自己做出决定，但我不会那样做。

Okay, with that out of the way.
好的，言归正传。

At the point that Claude code in Gemini CLI pretty much simultaneously finished Step Eight of the coding challenge, OpenAI was still struggling to complete step two.
当Claude Code和Gemini CLI几乎同时完成编程挑战的第八步时，OpenAI仍在努力完成第二步。

In previous experiments, I'd seen ChatGPT write the code needed to pass this challenge when I was giving it the prompts manually.
在之前的实验中，我曾看到ChatGPT在我手动提供提示时编写出通过这个挑战所需的代码。

So I don't think it's a failure in OpenAI's coding ability.
所以我认为这不是OpenAI编程能力的失败。

So much as, unlike Google, they haven't yet been able to catch up to Anthropic's work with their Claude code agent tool.
更多的是，与Google不同，他们尚未能赶上Anthropic在Claude Code智能体工具方面的工作。

I expect at some point, OpenAI will release it with similar functionality and assuming I can figure out a way to use it without giving away all my biometrics, I'll make a video about how it behaves.
我预计在某个时候，OpenAI会发布具有类似功能的工具，并且假设我能找到一种在使用它时无需泄露所有生物识别信息的方法，我将制作一个关于它表现的视频。

### Claude Code与Gemini CLI的对比

So, okay, onto a summary of what happened with the other two tools that did get to the end of the challenge successfully.
好的，接下来总结一下另外两个成功完成挑战的工具的表现。

If you want a lot more details, see the video on my other channel link below.
如果你想了解更多细节，请查看我另一个频道下方链接的视频。

So based on this experiment of the two, Gemini seems to be better than Claude code at following directions, although that's both good and bad.
所以根据这个实验，在这两者中，Gemini在遵循指示方面似乎比Claude Code更好，尽管这既是优点也是缺点。

Gemini wrote much more concise code.
Gemini编写的代码更加简洁。

It pretty much did what the extractions told it to had to do and not much more.
它几乎只做了提取指令要求它做的事情，不多也不少。

The code was harder to read.
代码更难阅读。

It didn't have any comments or explanations.
它没有任何注释或解释。

It did very little error checking.
它很少进行错误检查。

It was pretty much the bare minimum.
它几乎就是最低限度。

Claude code I find easier to use, especially the way they handle ToDo Lists is kind of cool.
我发现Claude Code更容易使用，特别是它们处理待办事项列表的方式有点酷。

And the code that Claude generated was better organized, better commented, easier to read and had better error checking.
Claude生成的代码组织更良好，注释更清晰，更易读，并且有更好的错误检查。

But it did do a bunch of stuff I didn't ask it to do.
但它确实做了一些我没有要求它做的事情。

And by the end, it had removed some functionality that had been needed in a previous step, which is what we call "introducing a **regression error** (Regression Error: 软件错误，指在进行某些更改后，某个功能停止工作)。"
到最后，它移除了一些在之前步骤中需要的功能，这正是我们所说的“引入了回归错误”。

So, Claude code might be better for you or it might be worse.
所以，Claude Code对你来说可能更好，也可能更糟。

If you're sure you know exactly what you want, then Gemini might be a better fit.
如果你确切知道自己想要什么，那么Gemini可能更适合。

If you want something that might help you out by going above and beyond what you ask for, Claude might be better.
如果你想要一个能超越你要求，提供额外帮助的工具，Claude可能更好。

### 智能体AI的局限性：上下文与测试

The problem that both of these tools, and in fact, pretty much all **Generative AI** (Generative AI: 能够生成各种类型内容（如文本、图像、音频和合成数据）的人工智能) of any kind struggle with, is context.
这两个工具，事实上几乎所有类型的生成式AI都面临的问题，是**上下文**（Context: AI在理解和生成内容时所依赖的语境信息）。

The more stuff you give them that they're supposed to do, the harder time they have remembering all the different things on the list and the more they are likely to break something that used to work.
你给它们要处理的东西越多，它们就越难记住列表中的所有不同事项，也越有可能破坏以前正常工作的功能。

Now, that's a thing that people can have trouble with too.
现在，这也是人们可能会遇到的问题。

And as an industry, we've developed techniques to help with that.
作为一个行业，我们已经开发出帮助解决这个问题的技术。

And the primary one is by writing **automated tests** (Automated Tests: 自动执行的软件测试，用于验证功能) at each step that can tell us later if previous functionality gets broken.
其中最主要的方法是在每个步骤编写自动化测试，以便日后能告诉我们之前的功能是否被破坏。

I've seen a number of people on the Internet opining that if you are worried about the quality of the code that you're getting from your AI, you can just tell your AI to write tests.
我看到互联网上许多人认为，如果你担心从AI那里得到的代码质量，你可以直接让AI编写测试。

But I can tell you from both personal experience, in this experiment and others, that generative AI is absolutely abysmal at writing tests.
但我可以告诉你，无论是从个人经验，还是从这次实验和其他实验来看，生成式AI在编写测试方面绝对糟糕透顶。

It makes sense if you think about it.
如果你仔细想想，这是有道理的。

The AI's have a lot less training data to draw from when it comes to writing good tests.
在编写高质量测试方面，AI可供借鉴的训练数据要少得多。

In this particular experiment with regard to automated testing, the two AI's failed in two different ways.
在这次关于自动化测试的特定实验中，这两个AI以两种不同的方式失败了。

Gemini, on each step, wrote a test to ostensibly help it verify that it had done what it was supposed to do.
Gemini在每一步都编写了一个测试，表面上是为了帮助它验证是否完成了应该做的事情。

And then, on each subsequent step, it would dismantle the previous tests and write a new one for the step it was currently on.
然后，在随后的每一步中，它都会拆除之前的测试，并为当前正在进行的步骤编写一个新的测试。

This defeats the whole purpose of testing and is pretty useless.
这完全违背了测试的目的，而且相当无用。

Claude wrote a bunch of tests and it kept them all, but they were really helpful.
Claude编写了一堆测试，并且全部保留了下来，但它们真的很有用。

So for example, the starting code for the project printed out a helpful message about how you can turn on debugging on Code Crafter's site if you need help troubleshooting.
例如，项目的起始代码打印出一条有用的消息，说明如果你需要故障排除帮助，如何在Code Crafter网站上开启调试。

Claude wrote a test to verify that the "just for your information" statement was always printed.
Claude编写了一个测试来验证“仅供参考”的声明是否始终被打印出来。

That print statement doesn't help anything and nothing would go wrong if it stopped, but Claude wanted to make sure it didn't go anywhere.
那个打印语句没有任何帮助，即使它停止了也不会出任何问题，但Claude想确保它不会消失。

On the other hand, Claude wrote zero tests that covered the vast majority of the required functionality.
另一方面，Claude没有编写任何覆盖绝大多数所需功能的测试。

There's a big complicated nested if-else block that's the core of the logic in the program.
程序的核心逻辑是一个庞大复杂的嵌套if-else块。

And Claude wrote tests for something like 3 of the 78 lines in that block.
而Claude只为那个块中78行代码中的大约3行编写了测试。

And when at some point it between step six and step eight, the functionality from step five of the challenge apparently ended up going missing.
当在第六步和第八步之间的某个时候，挑战第五步的功能显然最终消失了。

Claude had no idea, and the test didn't catch the fact that code had accidentally been removed.
Claude对此一无所知，测试也没有发现代码被意外移除的事实。

### 结论与未来展望

So where does that leave us?
那么，这给我们带来了什么？

In the easiest of the challenges I could think to throw at it, Claude and Gemini both managed to meet the minimum standard of the success criteria, but neither of them created code that was maintainable or well tested.
在我能想到的最简单的挑战中，Claude和Gemini都达到了成功标准的最低要求，但它们都没有创建出可维护或经过良好测试的代码。

By cracking open the code myself and prompting them specifically on what they need to do better, I have no doubt that I could eventually get them to produce code that was maintainable, at least for challenges this easy.
通过我自己打开代码，并明确提示它们需要改进的地方，我毫不怀疑我最终能让它们生成可维护的代码，至少对于这样简单的挑战来说是如此。

But one, cracking open the code goes to get the spirit of "Vibe Coding".
但第一，打开代码就违背了“Vibe Coding”的精神。

And two, I have decades of experience to know what maintainable code is, what I need to look for and what I need to ask the guys to do.
第二，我拥有数十年的经验，知道什么是可维护的代码，我需要寻找什么，以及我需要让这些工具做什么。

That's not true for a lot of the people that are excited about "Vibe Coding" at the moment.
对于目前许多对“Vibe Coding”感到兴奋的人来说，情况并非如此。

So if you are interested in "Vibe Coding", keep that in mind.
所以如果你对“Vibe Coding”感兴趣，请记住这一点。

So as far as what's next for the channel, now that I've finally figured out a reliable way to run these tests without me having to do a bunch of manual copy and pasting, there are a lot more experiments that I want to run.
至于频道接下来的计划，既然我终于找到了一个可靠的方法来运行这些测试，而无需我进行大量的手动复制粘贴，我还有很多实验想要进行。

Seriously, I've been trying for months to get something like this to work reliably and I finally managed to pull it off.
说真的，我几个月来一直试图让这样的东西可靠地工作，我终于成功了。

There are a lot more difficult challenges at code crafters.
Code Crafters上有更多困难的挑战。

So I'll definitely be doing some of those.
所以我肯定会做其中一些。

There are also some other agent tools like **OpenHands** (OpenHands: 曾用名OpenDevin，一款开源AI智能体，能够自主执行复杂的软件工程任务), which is what used to be OpenDevon that can talk to different AI vendors.
还有一些其他的智能体工具，比如OpenHands，它以前叫做OpenDevon，可以与不同的AI供应商对话。

So the idea of comparing Claude code's tool to a different command line tool that uses the same Claude backend model would be interesting.
所以，将Claude Code的工具与使用相同Claude后端模型的不同命令行工具进行比较会很有趣。

Same with using the exact same front end tool to go head to head between two different models.
同样，使用完全相同的前端工具来直接比较两种不同的模型。

That way we will know what the tool is responsible for getting right and wrong and what different the models actually make.
这样我们就能知道工具在哪些方面做得对或错，以及不同模型实际造成的差异。

Those experiment should be fun.
那些实验应该会很有趣。

So hit the subscribe button if you wanna know when those happen.
所以如果你想知道这些实验何时进行，请点击订阅按钮。

At the moment, if you are experimenting or wanting some code that you can run once and throw away, then I think "Vibe Coding" is a great option assuming your problem is simple enough.
目前，如果你正在进行实验或想要一些可以一次性运行并丢弃的代码，那么我认为“Vibe Coding”是一个不错的选择，前提是你的问题足够简单。

On the other hand, if you're wanting code that's going to need to be running reliably in production for a long period of time, then the current state of the art is nowhere near what you need.
另一方面，如果你想要的代码需要在生产环境中长期可靠运行，那么目前的最新技术远不能满足你的需求。

And I would urge you not to use "Vibe Coding" for anything that needs to be maintainable or anything that's going to be sitting on the internet in a place where hackers might be able to get to it because that's a recipe for making the internet less safe for everyone.
我强烈建议你不要将“Vibe Coding”用于任何需要维护的代码，或任何将放置在互联网上可能被黑客攻击的地方的代码，因为这会使互联网对所有人来说都变得不那么安全。

And the internet already has too many bugs.
而且互联网已经有太多bug了。

It doesn't need an additional bunch of vibe coding crap.
它不需要额外一堆“Vibe Coding”的垃圾。

So until next time, thank you all for watching.
那么，下次再见，感谢大家的观看。

Let's be careful out there.
大家在外要小心。

[BLANK_AUDIO]
[静音]