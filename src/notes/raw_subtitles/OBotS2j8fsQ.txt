在制作本期视频时
我想先通过AI了解一下版本号的发展史
打开copilot
我看到了15个可供选择的大模型
但我不知道该选哪个
因为我已经搞不懂它们有什么区别了
有时候4的回答比4.1和5更详细
有时候3.7的答案会比3.5和4.5更精准
所以每次我都要挨个问一遍
再货比三家得出结论
我十分怀念
那个什么软件
都可以无脑使用最新版本的时代
约定俗成的版本命名规则
在AI时代已经荡然无存
在计算机行业
一直以来我们都有一个默契
用统一的表达方式
来传达产品的迭代更新
这个表达方式就是版本号
Semantic versioning 就是一个很优秀的版本号格式
它由major minor patch三个数字组成
当一个产品的新版本包含影响重大的更新时
major就会上升一个数
比如Python圈子花了12年才完成的2.7-3.0的交接
这是因为代码不兼容
需要集体大规模重构
如果这个更新只包含一些可有可无的小功能
就会在minor上加一
如果发布的是某个bug的修复补丁
顾名思义，patch就会加1
semantic versioning通过三个数字的组合
浓缩了几乎所有产品迭代更新的情况
这也让它成为业内几乎默认的版本号格式
在这个基础上
不同产品也会根据自己的特殊情况进行调整
成熟的项目管理能让产品的发布周期稳定下来
比如10.0之后的世界上最好的数据库Postgres
会集中在每年的9月到10月左右发布新版本
所以他们会使用相对简洁的major加上patch的双数字格式
每年9月份major加一
剩下的时间里不定时发布补丁
作为Postgres的使用者
或者基于Postgres进行二次开发的程序员
都能有明确的预期管理
让整个Postgres生态更加稳定健康
又比如Linux内核也有固定的发布周期
但因为它的周期只有8个星期
所以major号膨胀的特别快
作为一个已经运作了30多年的项目
版本号码太大会很影响交流和传播
所以聪明的Linus决定把三数字格式当双数字格式用
2011年开始
每过大约20个周期
Linus就会让minor数归零
major数加一
就像加法那样进位
所以那些不太熟悉Linux生态的人
可能会误以为4:20-5:0或者5:19-6:0都是什么重大的系统更新
其实并不是
只是Linux刚好那天起床气比较重
决定cosplay一下归零者
有用短号的，自然也有用长号的
尤其是在CI/CD成熟的团队
一天发布10次也不为过
版本号自然复杂一些
但不管这些数字多长
有一点是不变的
开发者承诺了某种迭代更新的规律
用户由此可以更放心地按需升级
这种默契可以驱动非常大型的技术生态
比如大多数编程语言都有的package/dependency机制
在一个项目里引用成百上千个依赖
每个依赖都有自己的依赖
无穷无尽
如果要程序员自己去逐一管理，逐一检查每个依赖的更新
再去决定要不要升级依赖
那将会是不可能完成的任务
这个机制能存活下来
正是因为大家对于Semantic versioning版本号的默契
作为依赖的使用者
我们能大胆地接受所有依赖的所有patch版本更新
因为大大小小的新功能我们可能用不上
但现有功能的补丁修复总是需要的
当然
这种默契也会被不怀好意的人所利用
比如每隔半年左右
nodejs生态里就会出现被黑客攻陷的工具库
种下木马后以patch的形式发布
然后全世界千千万万的软件
在第二天上班时自动更新依赖，集体中招
但我认为
这更多的是npm这些包管理框架的安全机制上的缺陷
版本号只是一个导火索
默契真正脆弱的地方
其实来自于开发者的承诺
版本号这个东西
说白了就是一串数字
它没有任何国际标准
也没有任何法律约束力
它不像license那样
什么可以做
什么必须做
什么不可以做
做了之后有什么法律后果
都有非常明确的定义
版本号的定义遵循与否
只在开发者的一念之间
微信生态圈就是一个教科书式的反面案例
就拿小程序的基础库来说
虽然它的版本命名表面上遵循了Semantic versioning
但是版本号和变更的关系、变更的内容范围
都和Semantic versioning的定义没有一毛钱关系
在它的patch版本更新中
你可能会看到全新渲染引擎的发布
或者让基础组件的行为完全改变的功能改动
让人防不胜防
所以基础库每次发布更新公告
我们都得认真阅读、逐一核实
再决定要不要升级
但就算这样，你还是会被打个措手不及
因为小程序的运行底层实际上是一个黑箱
公开发布版本信息的基础库只是其中的一小部分
还有不少更新是不公开、不定时、不提醒的
而且这些更新会被直接推送到用户的微信上
这也意味着
哪天醒来，你随时可能收到用户愤怒的反馈
说你的小程序出故障了，不能用了
你debug半天无果
到微信开发者社区发帖询问
半天后才会有官方工作人员在评论区留下一句
“这个功能昨天改了/删掉了/不兼容了”
这也是为什么到了今天
即使已经成为（中国）国内c端软件的半壁江山
小程序的技术生态还是那么差
因为没有几个人想为这种丝毫不尊重开发者的平台做工具
而视频开头提到的大模型也走到了这个阶段
当纯粹的堆叠数据不再带来可观的性能跃升
大模型的版本号也开始变得混乱
GPT的4.1不一定比4好，5.0不一定比4.1好
Claude同时存在的3.5、3.7、4.0和4.5
并不是同一个模型的四次跃升
更像是四个完全不同的模型
AI公司彻底推翻了软件行业多年建立的认知体系
“新版是旧版的上位替代品”这个概念不再成立
而且所有版本的模型同时存在，同时提供服务
也让用户患上了选择困难症
其实这也不能完全怪罪开发者
因为大模型本质上就是一个千亿维度的黑箱
谁也说不准那些权重数字改动之后
到底影响了哪些地方
没有人能写出一个准确的大模型“更新日志”
开发者能做的，只有围绕几个Benchmark做测试
然后以他们的结果作为迭代的成果
这也是为什么有些人抱怨新模型更差了
有些人觉得新模型更好了
因为这完全取决于你的使用场景
是不是和AI公司优化的那个部分
刚好在同一个local minima的坑里
而随着大模型的竞争开始进入下半场
各大公司疯狂发布新版本的模型
又几乎不下架那些旧版本
只会让更多的人不知所措
既然这么误导人
为什么还是硬着头皮用数字版本来命名呢？
无非就是因为
普通消费者看不懂那些技术名词
那些专业的更新公告
但大家都能看懂数字
对于任何软件和硬件的消费
“买新不买旧”一直以来都被奉为真理
怎么判断什么是新的呢？
数字越大，它就越新呗
这也是为什么
微软折腾了XP和Vista之后
还是乖乖地回归了数字版本号
数字的信息密度和传播能力大于一切文字
在宣发和研发一样重要的大众行业
这就是最锋利的武器
只不过这个武器已然成为被滥用的工具
不讲武德的商家纯粹为了新闻效果
让宣发凌驾于研发之上
故意混淆版本的命名
某种程度上来说，这是一种“狼来了”的行为
每次发生，用户的信任都会被削掉一点
因为对于任何软件或硬件产品，用户永远都处于弱势地位
受到知识门槛、商业机密、时间成本等因素的影响
用户永远没有办法了解产品的全貌
我们只能选择相信
相信商家会自觉遵守那些约定俗成的规律
相信他们在一步一个脚印地优化自己的产品
相信接下来这个版本是值得掏钱的大更新
那么当信任被榨干之后
还能剩下什么呢？