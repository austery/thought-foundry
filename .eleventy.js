// ä½¿ç”¨åŠ¨æ€å¯¼å…¥ï¼Œæ‰€ä»¥ä¸»å‡½æ•°å¿…é¡»æ˜¯ async
module.exports = async function (eleventyConfig) {
  const { default: slugify } = await import("@sindresorhus/slugify");
  const { pinyin } = await import("pinyin");

  // --- è¿‡æ»¤å™¨ (Filters) ---
  eleventyConfig.addFilter("jsonify", function (value) {
    return JSON.stringify(value);
  });

  eleventyConfig.addFilter("slug", (str) => {
    if (!str) return;
    const trimmedStr = str.trim();
    const pinyinStr = pinyin(trimmedStr, { style: pinyin.STYLE_NORMAL }).join(
      " "
    );
    return slugify(pinyinStr);
  });

  // æ·»åŠ ä¸€ä¸ªè¿‡æ»¤å™¨æ¥è·å–æ¼”è®²è€…çš„å”¯ä¸€é”®
  eleventyConfig.addFilter(
    "getSpeakerUniqueKey",
    function (speakerName, collections) {
      if (!collections || !collections.speakerList)
        return slugify(
          pinyin(speakerName.trim().toLowerCase(), {
            style: pinyin.STYLE_NORMAL,
          }).join(" ")
        );

      const cleanedName = speakerName.replace(/^['"]|['"]$/g, "").trim();
      const lowerCaseName = cleanedName.toLowerCase();

      const speaker = collections.speakerList.find(
        (s) => s.key === lowerCaseName
      );
      return speaker ? speaker.uniqueKey : lowerCaseName;
    }
  );

  // --- é›†åˆ (Collections) ---

  // é›†åˆ 1, 2, 3: ä¿æŒä¸å˜
  eleventyConfig.addCollection("posts", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/posts/**/*.md");
  });
  eleventyConfig.addCollection("books", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/books/**/*.md");
  });
  eleventyConfig.addCollection("notes", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/notes/**/*.md");
  });

  // é›†åˆ 4: è¿™æ˜¯æˆ‘ä»¬æœ€ç»ˆçš„ã€æœ€å¯é çš„æ ‡ç­¾é›†åˆï¼Œç°åœ¨å¢åŠ äº†æ›´å¼ºå¤§çš„è°ƒè¯•æŠ¥å‘ŠåŠŸèƒ½
  eleventyConfig.addCollection("tagList", (collectionApi) => {
    const tagMap = new Map();
    collectionApi.getAll().forEach((item) => {
      // æˆ‘ä»¬åªå¤„ç†é‚£äº›åœ¨ posts, books, æˆ– notes æ–‡ä»¶å¤¹é‡Œçš„å†…å®¹
      if (
        item.inputPath.includes("./src/posts/") ||
        item.inputPath.includes("./src/books/") ||
        item.inputPath.includes("./src/notes/")
      ) {
        (item.data.tags || []).forEach((tag) => {
          const lowerCaseTag = tag.trim().toLowerCase();
          if (!tagMap.has(lowerCaseTag)) {
            tagMap.set(lowerCaseTag, {
              name: tag,
              key: lowerCaseTag,
              posts: [],
              // æ–°å¢ï¼šè®°å½•è¿™ä¸ªæ ‡ç­¾æ¥è‡ªå“ªäº›æ–‡ä»¶
              sources: new Set(),
            });
          }
          tagMap.get(lowerCaseTag).posts.push(item);
          // å°†å½“å‰æ–‡ä»¶çš„è·¯å¾„æ·»åŠ åˆ°æ¥æºé›†åˆä¸­
          tagMap.get(lowerCaseTag).sources.add(item.inputPath);
        });
      }
    });

    const tagList = Array.from(tagMap.values()).sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    // --- START: è°ƒè¯•ä»£ç æ¥å¯»æ‰¾å†²çª ---
    const slugConflictMap = new Map();
    const slugifyFilter = eleventyConfig.getFilter("slug");

    tagList.forEach((tagInfo) => {
      const slug = slugifyFilter(tagInfo.key);
      if (!slugConflictMap.has(slug)) {
        slugConflictMap.set(slug, []);
      }
      // æˆ‘ä»¬ç°åœ¨å­˜å‚¨æ›´è¯¦ç»†çš„ä¿¡æ¯
      slugConflictMap.get(slug).push({
        name: tagInfo.name,
        sources: Array.from(tagInfo.sources),
      });
    });

    console.log("\n--- Tag Slug Conflict Report ---");
    let foundConflict = false;
    slugConflictMap.forEach((tags, slug) => {
      if (tags.length > 1) {
        console.error(
          `[!! CONFLICT FOUND !!] The slug "${slug}" is generated by these tags:`
        );
        tags.forEach((tagData) => {
          console.error(
            `  - Tag: "${
              tagData.name
            }" is found in file(s): ${tagData.sources.join(", ")}`
          );
        });
        foundConflict = true;
      }
    });

    if (!foundConflict) {
      console.log("No tag conflicts found. All slugs are unique.");
    }
    console.log("--------------------------------\n");
    // --- END: è°ƒè¯•ä»£ç  ---

    return tagList;
  });

  // é›†åˆ 5: æ¼”è®²è€…é›†åˆ - ç±»ä¼¼äºæ ‡ç­¾é›†åˆä½†ä¸“é—¨å¤„ç†æ¼”è®²è€…
  eleventyConfig.addCollection("speakerList", (collectionApi) => {
    const speakerMap = new Map();
    collectionApi.getAll().forEach((item) => {
      // æˆ‘ä»¬åªå¤„ç†é‚£äº›åœ¨ posts, books, æˆ– notes æ–‡ä»¶å¤¹é‡Œçš„å†…å®¹
      if (
        item.inputPath.includes("./src/posts/") ||
        item.inputPath.includes("./src/books/") ||
        item.inputPath.includes("./src/notes/")
      ) {
        // å¤„ç† speaker å’Œ guest å­—æ®µ
        const allSpeakers = [];
        
        // ä» speaker å­—æ®µæå–æ¼”è®²è€…
        const speaker = item.data.speaker;
        if (speaker && speaker.trim() !== "" && speaker.trim() !== "''") {
          const speakers = speaker
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s !== "");
          allSpeakers.push(...speakers);
        }
        
        // ä» guest å­—æ®µæå–å˜‰å®¾
        const guest = item.data.guest;
        if (guest && guest.trim() !== "" && guest.trim() !== "''") {
          const guests = guest
            .split(",")
            .map((g) => g.trim())
            .filter((g) => g !== "");
          allSpeakers.push(...guests);
        }
        
        // å»é‡å¹¶å¤„ç†æ‰€æœ‰æ¼”è®²è€…
        const uniqueSpeakers = [...new Set(allSpeakers.map(s => s.toLowerCase()))]
          .map(lowercaseName => allSpeakers.find(s => s.toLowerCase() === lowercaseName));
          
        uniqueSpeakers.forEach((speakerName) => {
          // æ¸…ç†æ¼”è®²è€…åç§°ï¼šå»é™¤å¼•å·å’Œé¢å¤–ç©ºæ ¼
          const cleanedName = speakerName.replace(/^['"]|['"]$/g, "").trim();
          if (cleanedName !== "") {
            const lowerCaseSpeaker = cleanedName.toLowerCase();
            if (!speakerMap.has(lowerCaseSpeaker)) {
              speakerMap.set(lowerCaseSpeaker, {
                name: cleanedName,
                key: lowerCaseSpeaker,
                posts: [],
                sources: new Set(),
              });
            }
            speakerMap.get(lowerCaseSpeaker).posts.push(item);
            speakerMap.get(lowerCaseSpeaker).sources.add(item.inputPath);
          }
        });
      }
    });

    const speakerList = Array.from(speakerMap.values()).sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    // Debug output for speaker conflicts and resolve slug conflicts
    console.log("\n--- Speaker Slug Conflict Report ---");
    const slugConflictMap = new Map();
    const slugifyFilter = eleventyConfig.getFilter("slug");

    // First pass: detect conflicts
    speakerList.forEach((speakerInfo) => {
      const slug = slugifyFilter(speakerInfo.key);
      if (!slugConflictMap.has(slug)) {
        slugConflictMap.set(slug, []);
      }
      slugConflictMap.get(slug).push(speakerInfo);
    });

    // Second pass: resolve conflicts by adding unique identifiers
    let foundConflict = false;
    slugConflictMap.forEach((speakers, slug) => {
      if (speakers.length > 1) {
        console.error(
          `[!! SPEAKER CONFLICT FOUND !!] The slug "${slug}" is generated by these speakers:`
        );
        speakers.forEach((speakerData, index) => {
          console.error(
            `  - Speaker: "${
              speakerData.name
            }" is found in file(s): ${Array.from(speakerData.sources).join(
              ", "
            )}`
          );
          // Resolve conflict by adding index suffix
          speakerData.uniqueKey = `${speakerData.key}-${index + 1}`;
        });
        foundConflict = true;
      } else {
        // No conflict, use original key
        speakers[0].uniqueKey = speakers[0].key;
      }
    });

    if (!foundConflict) {
      console.log("No speaker conflicts found. All slugs are unique.");
    } else {
      console.log("Conflicts resolved by adding unique identifiers.");
    }
    console.log("------------------------------------\n");

    return speakerList;
  });

  // --- START: æ–°å¢çš„ä¸´æ—¶ä¾¦æµ‹ä»£ç  ---
  // é›†åˆ 6: è¿™ä¸ªé›†åˆä¸“é—¨ç”¨æ¥å¯»æ‰¾æœ‰é—®é¢˜çš„ speaker å­—æ®µ
  eleventyConfig.addCollection("longSpeakerDetector", function (collectionApi) {
    console.log("\n--- Checking for long speaker fields ---");
    let problemsFound = 0;
    const problematicFiles = [];
    
    collectionApi.getAll().forEach((item) => {
      // æ£€æŸ¥å¤šç§å¯èƒ½çš„æ•°æ®è·¯å¾„
      let speaker = null;
      
      // å°è¯•ä¸åŒçš„æ•°æ®è®¿é—®è·¯å¾„
      if (item.data && item.data.speaker) {
        speaker = item.data.speaker;
      } else if (item.data && item.data.data && item.data.data.speaker) {
        speaker = item.data.data.speaker;
      }
      
      // å¦‚æœæ‰¾åˆ°äº† speaker å­—æ®µ
      if (speaker) {
        // å¦‚æœ speaker æ˜¯å­—ç¬¦ä¸²å¹¶ä¸”é•¿åº¦è¶…è¿‡ 100 ä¸ªå­—ç¬¦
        if (typeof speaker === "string" && speaker.length > 100) {
          problemsFound++;
          problematicFiles.push({
            file: item.inputPath,
            length: speaker.length,
            preview: speaker.substring(0, 200)
          });
          
          console.error(`\n[!! POTENTIAL PROBLEM FOUND !!]`);
          console.error(`File: ${item.inputPath}`);
          console.error(`Speaker field is too long (length: ${speaker.length})`);
          console.error(`First 200 characters of speaker field:`);
          console.error(`"${speaker.substring(0, 200)}..."`);
          console.error(`---`);
        }
        
        // ä¹Ÿæ£€æŸ¥æ˜¯å¦åŒ…å«æ¢è¡Œç¬¦æˆ–å…¶ä»–å¥‡æ€ªå­—ç¬¦
        if (typeof speaker === "string" && (speaker.includes('\n') || speaker.includes('\r'))) {
          console.warn(`[!! WARNING !!] Speaker field contains newlines in: ${item.inputPath}`);
          console.warn(`Speaker preview: "${speaker.substring(0, 100)}..."`);
        }
      }
    });
    
    console.log(`--- Check complete: ${problemsFound} problems found ---`);
    
    if (problemsFound > 0) {
      console.log(`\nğŸ”§ FILES THAT NEED FIXING:`);
      problematicFiles.forEach((problem, index) => {
        console.log(`${index + 1}. File: ${problem.file}`);
        console.log(`   Length: ${problem.length} characters`);
        console.log(`   Preview: "${problem.preview}..."`);
        console.log('');
      });
      console.log(`\nğŸ’¡ RECOMMENDATION: Fix the speaker field in these files by:`);
      console.log(`   1. Moving the content from 'speaker:' to the main body`);
      console.log(`   2. Adding a proper speaker name (or leave blank if unknown)`);
      console.log(`   3. Ensuring proper YAML frontmatter formatting\n`);
    }
    
    return []; // è¿™ä¸ªé›†åˆä¸éœ€è¦è¾“å‡ºä»»ä½•ä¸œè¥¿
  });
  // --- END: æ–°å¢çš„ä¸´æ—¶ä¾¦æµ‹ä»£ç  ---

  // --- Passthrough Copy & æ ¸å¿ƒé…ç½® (ä¿æŒä¸å˜) ---
  eleventyConfig.addPassthroughCopy("src/js");
  eleventyConfig.addPassthroughCopy("src/css");

  return {
    pathPrefix:
      process.env.NODE_ENV === "production" ? "/thought-foundry/" : "/",
    dir: {
      input: "src",
      output: "_site",
      includes: "_includes",
    },
  };
};
