// 使用动态导入，所以主函数必须是 async
module.exports = async function (eleventyConfig) {
  const { default: slugify } = await import("@sindresorhus/slugify");
  const { pinyin } = await import("pinyin");

  // --- 过滤器 (Filters) ---
  eleventyConfig.addFilter("jsonify", function (value) {
    return JSON.stringify(value);
  });

  eleventyConfig.addFilter("slug", (str) => {
    if (!str) return;
    const trimmedStr = str.trim();
    const pinyinStr = pinyin(trimmedStr, { style: pinyin.STYLE_NORMAL }).join(
      " "
    );
    return slugify(pinyinStr);
  });

  // 添加一个过滤器来获取演讲者的唯一键
  eleventyConfig.addFilter("getSpeakerUniqueKey", function(speakerName, collections) {
    if (!collections || !collections.speakerList) return slugify(pinyin(speakerName.trim().toLowerCase(), { style: pinyin.STYLE_NORMAL }).join(" "));
    
    const cleanedName = speakerName.replace(/^['"]|['"]$/g, '').trim();
    const lowerCaseName = cleanedName.toLowerCase();
    
    const speaker = collections.speakerList.find(s => s.key === lowerCaseName);
    return speaker ? speaker.uniqueKey : lowerCaseName;
  });

  // --- 集合 (Collections) ---

  // 集合 1, 2, 3: 保持不变
  eleventyConfig.addCollection("posts", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/posts/**/*.md");
  });
  eleventyConfig.addCollection("books", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/books/**/*.md");
  });
  eleventyConfig.addCollection("notes", function (collectionApi) {
    return collectionApi.getFilteredByGlob("./src/notes/**/*.md");
  });

  // 集合 4: 这是我们最终的、最可靠的标签集合，现在增加了更强大的调试报告功能
  eleventyConfig.addCollection("tagList", (collectionApi) => {
    const tagMap = new Map();
    collectionApi.getAll().forEach((item) => {
      // 我们只处理那些在 posts, books, 或 notes 文件夹里的内容
      if (
        item.inputPath.includes("./src/posts/") ||
        item.inputPath.includes("./src/books/") ||
        item.inputPath.includes("./src/notes/")
      ) {
        (item.data.tags || []).forEach((tag) => {
          const lowerCaseTag = tag.trim().toLowerCase();
          if (!tagMap.has(lowerCaseTag)) {
            tagMap.set(lowerCaseTag, {
              name: tag,
              key: lowerCaseTag,
              posts: [],
              // 新增：记录这个标签来自哪些文件
              sources: new Set(),
            });
          }
          tagMap.get(lowerCaseTag).posts.push(item);
          // 将当前文件的路径添加到来源集合中
          tagMap.get(lowerCaseTag).sources.add(item.inputPath);
        });
      }
    });

    const tagList = Array.from(tagMap.values()).sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    // --- START: 调试代码来寻找冲突 ---
    const slugConflictMap = new Map();
    const slugifyFilter = eleventyConfig.getFilter("slug");

    tagList.forEach((tagInfo) => {
      const slug = slugifyFilter(tagInfo.key);
      if (!slugConflictMap.has(slug)) {
        slugConflictMap.set(slug, []);
      }
      // 我们现在存储更详细的信息
      slugConflictMap.get(slug).push({
        name: tagInfo.name,
        sources: Array.from(tagInfo.sources),
      });
    });

    console.log("\n--- Tag Slug Conflict Report ---");
    let foundConflict = false;
    slugConflictMap.forEach((tags, slug) => {
      if (tags.length > 1) {
        console.error(
          `[!! CONFLICT FOUND !!] The slug "${slug}" is generated by these tags:`
        );
        tags.forEach((tagData) => {
          console.error(
            `  - Tag: "${
              tagData.name
            }" is found in file(s): ${tagData.sources.join(", ")}`
          );
        });
        foundConflict = true;
      }
    });

    if (!foundConflict) {
      console.log("No tag conflicts found. All slugs are unique.");
    }
    console.log("--------------------------------\n");
    // --- END: 调试代码 ---

    return tagList;
  });

  // 集合 5: 演讲者集合 - 类似于标签集合但专门处理演讲者
  eleventyConfig.addCollection("speakerList", (collectionApi) => {
    const speakerMap = new Map();
    collectionApi.getAll().forEach((item) => {
      // 我们只处理那些在 posts, books, 或 notes 文件夹里的内容
      if (
        item.inputPath.includes("./src/posts/") ||
        item.inputPath.includes("./src/books/") ||
        item.inputPath.includes("./src/notes/")
      ) {
        const speaker = item.data.speaker;
        if (speaker && speaker.trim() !== '') {
          // 处理多个演讲者的情况，用逗号分隔
          const speakers = speaker.split(',').map(s => s.trim()).filter(s => s !== '');
          speakers.forEach((speakerName) => {
            // 清理演讲者名称：去除引号和额外空格
            const cleanedName = speakerName.replace(/^['"]|['"]$/g, '').trim();
            if (cleanedName !== '') {
              const lowerCaseSpeaker = cleanedName.toLowerCase();
              if (!speakerMap.has(lowerCaseSpeaker)) {
                speakerMap.set(lowerCaseSpeaker, {
                  name: cleanedName,
                  key: lowerCaseSpeaker,
                  posts: [],
                  sources: new Set(),
                });
              }
              speakerMap.get(lowerCaseSpeaker).posts.push(item);
              speakerMap.get(lowerCaseSpeaker).sources.add(item.inputPath);
            }
          });
        }
      }
    });

    const speakerList = Array.from(speakerMap.values()).sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    // Debug output for speaker conflicts and resolve slug conflicts
    console.log("\n--- Speaker Slug Conflict Report ---");
    const slugConflictMap = new Map();
    const slugifyFilter = eleventyConfig.getFilter("slug");

    // First pass: detect conflicts
    speakerList.forEach((speakerInfo) => {
      const slug = slugifyFilter(speakerInfo.key);
      if (!slugConflictMap.has(slug)) {
        slugConflictMap.set(slug, []);
      }
      slugConflictMap.get(slug).push(speakerInfo);
    });

    // Second pass: resolve conflicts by adding unique identifiers
    let foundConflict = false;
    slugConflictMap.forEach((speakers, slug) => {
      if (speakers.length > 1) {
        console.error(
          `[!! SPEAKER CONFLICT FOUND !!] The slug "${slug}" is generated by these speakers:`
        );
        speakers.forEach((speakerData, index) => {
          console.error(
            `  - Speaker: "${
              speakerData.name
            }" is found in file(s): ${Array.from(speakerData.sources).join(", ")}`
          );
          // Resolve conflict by adding index suffix
          speakerData.uniqueKey = `${speakerData.key}-${index + 1}`;
        });
        foundConflict = true;
      } else {
        // No conflict, use original key
        speakers[0].uniqueKey = speakers[0].key;
      }
    });

    if (!foundConflict) {
      console.log("No speaker conflicts found. All slugs are unique.");
    } else {
      console.log("Conflicts resolved by adding unique identifiers.");
    }
    console.log("------------------------------------\n");

    return speakerList;
  });

  // --- Passthrough Copy & 核心配置 (保持不变) ---
  eleventyConfig.addPassthroughCopy("src/js");
  eleventyConfig.addPassthroughCopy("src/css");

  return {
    pathPrefix:
      process.env.NODE_ENV === "production" ? "/thought-foundry/" : "/",
    dir: {
      input: "src",
      output: "_site",
      includes: "_includes",
    },
  };
};
